{
  "version": 3,
  "sources": ["../../../../../node_modules/@fireflysemantics/angular-stripe-service/fesm2020/fireflysemantics-angular-stripe-service.mjs"],
  "sourcesContent": ["import * as i0 from '@angular/core';\nimport { Injectable } from '@angular/core';\nconst STRIPE_API_URL = \"https://js.stripe.com/v3/\";\n/**\n * This service has a `stripe` property to that gets\n * initialized to `window[\"Stripe\"]`.\n *\n * The constructor calls `inject()` which will\n * inject a script tag with containing the URL that loads\n * stripe and return a `Promise<StripeFactory>`.\n *\n * The script tag will only load stripe if\n * c is not available.\n *\n * If `window[\"Stripe\"]` is available then `inject()` resolves\n * the promise with that instance immediately, and does not create and\n * wait for the script tag to load.\n *\n *\n */\nclass AngularStripeService {\n  constructor() {\n    // @ts-ignore\n    this._stripe = window['Stripe'];\n    this.stripePromise = this.inject();\n  }\n  get stripe() {\n    return this._stripe;\n  }\n  set stripe(s) {\n    this._stripe = s;\n  }\n  setPublishableKey(key, options) {\n    return this.stripePromise.then(() => {\n      return this.stripe(key, options);\n    });\n  }\n  inject() {\n    if (this.stripe) {\n      return Promise.resolve(this.stripe);\n    }\n    return new Promise((res, rej) => {\n      const head = this.getHeadElement();\n      const script = document.createElement(\"script\");\n      script.setAttribute(\"type\", \"text/javascript\");\n      script.setAttribute(\"src\", STRIPE_API_URL);\n      head.appendChild(script);\n      script.addEventListener(\"load\", () => {\n        // @ts-ignore\n        this.stripe = window[\"Stripe\"];\n        res(this.stripe);\n      });\n    });\n  }\n  /**\n   * Returns the `head` element.\n   * @throws Error('Application does not have a head element');\n   */\n  getHeadElement() {\n    let elm = document.getElementsByTagName(\"head\")[0];\n    if (!elm) {\n      throw new Error('Application does not have a head element');\n    }\n    return elm;\n  }\n}\nAngularStripeService.ɵfac = function AngularStripeService_Factory(t) {\n  return new (t || AngularStripeService)();\n};\nAngularStripeService.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n  token: AngularStripeService,\n  factory: AngularStripeService.ɵfac,\n  providedIn: 'root'\n});\n(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(AngularStripeService, [{\n    type: Injectable,\n    args: [{\n      providedIn: 'root'\n    }]\n  }], function () {\n    return [];\n  }, null);\n})();\n\n/*\n * Public API Surface of angular-stripe-service\n */\n\n/**\n * Generated bundle index. Do not edit.\n */\n\nexport { AngularStripeService };\n"],
  "mappings": ";;;;;;;;;;;;AAEA,IAAM,iBAAiB;AAkBvB,IAAM,uBAAN,MAA2B;AAAA,EACzB,cAAc;AAEZ,SAAK,UAAU,OAAO,QAAQ;AAC9B,SAAK,gBAAgB,KAAK,OAAO;AAAA,EACnC;AAAA,EACA,IAAI,SAAS;AACX,WAAO,KAAK;AAAA,EACd;AAAA,EACA,IAAI,OAAO,GAAG;AACZ,SAAK,UAAU;AAAA,EACjB;AAAA,EACA,kBAAkB,KAAK,SAAS;AAC9B,WAAO,KAAK,cAAc,KAAK,MAAM;AACnC,aAAO,KAAK,OAAO,KAAK,OAAO;AAAA,IACjC,CAAC;AAAA,EACH;AAAA,EACA,SAAS;AACP,QAAI,KAAK,QAAQ;AACf,aAAO,QAAQ,QAAQ,KAAK,MAAM;AAAA,IACpC;AACA,WAAO,IAAI,QAAQ,CAAC,KAAK,QAAQ;AAC/B,YAAM,OAAO,KAAK,eAAe;AACjC,YAAM,SAAS,SAAS,cAAc,QAAQ;AAC9C,aAAO,aAAa,QAAQ,iBAAiB;AAC7C,aAAO,aAAa,OAAO,cAAc;AACzC,WAAK,YAAY,MAAM;AACvB,aAAO,iBAAiB,QAAQ,MAAM;AAEpC,aAAK,SAAS,OAAO,QAAQ;AAC7B,YAAI,KAAK,MAAM;AAAA,MACjB,CAAC;AAAA,IACH,CAAC;AAAA,EACH;AAAA;AAAA;AAAA;AAAA;AAAA,EAKA,iBAAiB;AACf,QAAI,MAAM,SAAS,qBAAqB,MAAM,EAAE,CAAC;AACjD,QAAI,CAAC,KAAK;AACR,YAAM,IAAI,MAAM,0CAA0C;AAAA,IAC5D;AACA,WAAO;AAAA,EACT;AACF;AACA,qBAAqB,OAAO,SAAS,6BAA6B,GAAG;AACnE,SAAO,KAAK,KAAK,sBAAsB;AACzC;AACA,qBAAqB,QAA0B,mBAAmB;AAAA,EAChE,OAAO;AAAA,EACP,SAAS,qBAAqB;AAAA,EAC9B,YAAY;AACd,CAAC;AAAA,CACA,MAAM;AACL,GAAC,OAAO,cAAc,eAAe,cAAiB,iBAAkB,sBAAsB,CAAC;AAAA,IAC7F,MAAM;AAAA,IACN,MAAM,CAAC;AAAA,MACL,YAAY;AAAA,IACd,CAAC;AAAA,EACH,CAAC,GAAG,WAAY;AACd,WAAO,CAAC;AAAA,EACV,GAAG,IAAI;AACT,GAAG;",
  "names": []
}
